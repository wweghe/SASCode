#!/bin/bash -p
#
# Copyright (c) 2017, SAS Institute Inc., Cary, NC, USA, All Rights Reserved
#
# SAS basic init.d functions
# these do NOT necessarily mimic LSB functionality
#
# revised 06/17/2016 - cleaned up error handling, allow for dashes in prodname
#

# set some script globals defining IDs for this init script instance
# returned as non-local env vars
#

# sas_set_env - sets various SAS env symbols based on calling script's name
#
# defines:
#   SASINITPATH     - canonical path to the invoking script
#   SASINITBASE     - basename of the invoking script
#                     (formatted as: "sas-<deploymentID>-<productname>-<instanceID>")
#   SASDEPLOYID     - deployment ID name (typically is "viya")
#   SASPRODNAME     - product name (example: "spawner")
#   SASINSTID       - product instance name (typically is "default")
#
# returns 0 on success, 1 on failure
#


SYSTYPE=$(ps -p 1 | grep -v PID | awk '{ print $4 }')

sas_set_env() {
  local testver

# Make sure this the correct version of sas_init_functions
# Future releases can make this a switch/case to pull in the correct subfile
# instead of directly in-lining the function set

  testver="${1:-'(no version defined)'}"
  if [ "$testver" != "v1" ]; then
    sas_log_failure_msg "sas_init_functions: SASINITVER is an incompatible version: $testver"
    return 1
  fi


  SASINITPATH=$(readlink -nf $0)

  SASINITBASE=$(basename $SASINITPATH)
  SASDEPLOYID=$(echo $SASINITBASE | awk -F'-' '{print $2}')
  SASINSTID=$(echo $SASINITBASE | awk -F'-' '{print $NF}')
# this nightmare allows for dashes in the product name
  SASPRODNAME=$(echo $SASINITBASE | awk -F'-' '{ for (i=3; i<NF; i++) printf("%s%s", $(i), i<(NF-1) ? "-" : "");}')

# sanity check - if one of these is null, the basename is not the correct format
  if [ -z "$SASINSTID" -o -z "$SASDEPLOYID" -o -z "$SASPRODNAME" ]; then
    sas_log_warning_msg "sas_init_functions: an expected script name element is NULL"
    sas_log_warning_msg "sas_init_functions: SASINITBASE=$SASINITBASE"
    sas_log_warning_msg "sas_init_functions: SASINSTID=$SASINSTID"
    sas_log_warning_msg "sas_init_functions: SASDEPLOYID=$SASDEPLOYID"
    sas_log_warning_msg "sas_init_functions: SASPRODNAME=$SASPRODNAME"
    return 1
  fi

  return 0
}

#
# sas_check_pid - checks if process described in pidfile ($2) is running
#
# Checks to see if pidfile exists, if not, assume not running.
# If pidfile exists, read contents for *single PID*, then kill -0 that pid
# to see if the process is active. Under Linux, this may be rewritten to
# check the /proc/<id> hierarchy.
#
# usage:
#
#   sas_check_pid -p pidfile
#
# Note: "-p" is required - this is to maintain equivalence with LSB pidofproc syntax
#
# returns LSB-style status:
#   0 - program running
#   1 - not running, but pidfile exists
#   3 - no pidfile found, assume not running
#   4 - error calling this function, status of PID unknown
#
# Note - some pidfiles contain multiple pids.  If even one pid is still active, then
# we call that success, i.e. running.  Example: sas-viya-httpproxy-default.pid
#

sas_check_pid() {
  local pid
  local pidopt
  local pidfile
  local result
  local pidOut
  local pidList

  pidopt="$1"
  pidfile="$2"
  if [ "$pidopt" != "-p" ] || [ -z "$pidfile" ]; then
    sas_log_warning_msg "$SASINITBASE sas_check_pid did not specify a pidfile"
    result=4  # status unknown
  elif [ -f "$pidfile" ]; then
    pidList=`cat $pidfile`
    for pid in $pidList; do
#        pidOut=`ps --no-headers -ostat -p $pid`
        pidOut=`ps -p $pid`
        if [ $? -eq 0 ]; then
#           echo $pidOut | grep -v '[Zz]' > /dev/null 2>&1
#           if [ $? -eq 0 ]; then
#              result=0  # is running
#              break
#           else
#              result=1  # is a zombie, pid file exists, bad news
#              break
#           fi

            result=0  # is running
			# ESM CONFIG START
export ESMHOME=/opt/sas/esm-agent
export esmfuncfile=$ESMHOME/addPid.sh
if [ -f "$esmfuncfile" ]; then
  source $esmfuncfile

  esmthislogloc=${SASLOGROOT}/${SASPRODNAME}/${SASINSTANCE}/
  # uncomment this for logfile tracking
  esmservicelogfile="${esmthislogloc}$(ls -t $esmthislogloc | head -n1)"

  esmReportPid $pid "${SASPRODNAME}" "viya" "${esmservicelogfile}" "${SASINSTANCE}"
fi
# ESM CONFIG END
         else
          result=1  # is not runnning, but pid file exists
        fi
    done
  else
    result=3  # no pid file exists (assume not running)
  fi

  return $result
}

sas_stop_pid() {
# -p pid file containing process ID to terminate
# -t time in seconds to delay after SIGTERM before deciding to kill the process
# -u username to use with the kill command
#
# returns 0 on success, 1 on failure
#
local pid
local pidfile
local killdelay=30   # default time in seconds to wait after SIGTERM before killing the pid
local theUsername
local scriptName
local zPid
local theParentPid
local result=0

if [[ "${SYSTYPE}" == "systemd" ]]
then
    zPid=$BASHPID
    theParentPid=$(ps --no-headers -fp $zPid | awk '{print $3}')
    if [[ $theParentPid -ne 1 ]]; then
	scriptName=$(basename $0)
        echo "[ERROR] Use systemctl to start/stop Viya services: systemctl stop" $scriptName
        exit 2
    fi
fi

while [ -n "$1" ]
do
    case "$1" in
      -p)
        shift
        pidfile="$1"
        ;;

      -t)  # delay nn seconds after SIGTERMs before SIGKILL
        shift
        killdelay="$1"
        ;;

      -u)  # use given username to kill pid
        shift
        theUsername="$1"
        ;;

       *)
        break  # don't recognize argument as expected opt, break and let something else consume those
        ;;
    esac
    shift  # discard the option's value
done

if [[ -f $pidfile ]]; then
    local countdown
    local polldelay=5

    if [[ -z $theUsername ]]; then
        killcmd="kill"
    elif [[ -x /sbin/runuser ]]; then
        killcmd="/sbin/runuser -s /bin/bash $theUsername kill"
    else
        # runuser is preferred as it works with SELinux, but we fallback to su
        killcmd="su $theUsername kill"
    fi

    pid=`cat $pidfile`
    $killcmd -TERM $pid >/dev/null 2>&1
    sleep 1

    # try to shutdown cleanly at $polldelay second intervals for $killdelay seconds
    for (( countdown=killdelay; countdown>0; countdown-=polldelay ))
    do
        # try again - done if pid no longer exists
        $killcmd -TERM $pid >/dev/null 2>&1 || break
        sleep $polldelay
    done

    # if pid still around, terminate with extreme prejudice
    if [[ $countdown -le 0 ]]; then
        $killcmd -KILL $pid >/dev/null 2>&1
        sleep 2
        $killcmd -0 $pid >/dev/null 2>&1 && result=1  # error result if pid still exists
    fi

    if [[ $result -eq 0 && -f $pidfile ]]; then
        rm "$pidfile"  # clean up the pidfile if needed
    fi
fi

return $result
}

# minimal msg functionality for now
sas_log_success_msg()
{
  echo $*
  return 0
}

# internal debugging messages - if SASINITDEBUG is non-null output message
sas_debug_msg()
{
  if [ -n "$SASINITDEBUG" ]; then
    echo $*
  fi
  return 0
}

sas_log_warning_msg()
{
  echo $*
  return 0
}

sas_log_failure_msg()
{
  echo $*
  return 0
}

# sas_start_service - invoke the described service as the given userID
#
# sas_start_service <userid> -c <commandstring>
#
# all options are Required
#
sas_start_service()
{
local uid
local result
local scriptName
local zPid
local theParentPid

if [[ "${SYSTYPE}" == "systemd" ]]
then
    zPid=$BASHPID
    theParentPid=$(ps --no-headers -fp $zPid | awk '{print $3}')
    if [[ $theParentPid -ne 1 ]]; then
	scriptName=$(basename $0)
        echo "[ERROR] Use systemctl to start/stop Viya services: systemctl start" $scriptName
        exit 2
    fi
fi
# runuser is preferred as it works with SELinux, but we fallback to su
    if [ -x /sbin/runuser ]; then
        RU='/sbin/runuser -s /bin/bash '
    else
        RU=su
    fi

  if [ $# -lt 3 ]; then
    return 1  # didn't specify required command options
  fi

  uid="$1"; shift;

  $RU $uid -c "$*"

  return $?
}

